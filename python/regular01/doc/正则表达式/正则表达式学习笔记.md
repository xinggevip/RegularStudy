## 正则表达式学习笔记

### 什么是正则表达式 ？

> 正则表达式是一种被用于从文本中检索符合某些特定模式的文本。

正则表达式是从左到右来匹配一个字符串的。"Regular Expression" 这个词太长了，我们通常使用它的缩写 "regex" 或者 "regexp"。
正则表达式可以被用来替换字符串中的文本、验证表单、基于模式匹配从一个字符串中提取字符串等等。

想象一下，您正在编写应用程序，并且您希望在用户选择用户名时设置规则。我们希望用户名可以包含字母，数字，下划线和连字符。
为了让它看起来不丑，我们还想限制用户名中的字符数量。我们可以使用以下正则表达式来验证用户名

### 1. 简写字符集

正则表达式为常用的字符集和常用的正则表达式提供了简写。简写字符集如下:

| 简写 | 描述                                     |
| :--: | ---------------------------------------- |
|  .   | 匹配除换行符以外的任意字符               |
|  \w  | 匹配所有字母和数字的字符: `[a-zA-Z0-9_]` |
|  \W  | 匹配非字母和数字的字符: `[^\w]`          |
|  \d  | 匹配数字: `[0-9]`                        |
|  \D  | 匹配非数字: `[^\d]`                      |
|  \s  | 匹配空格符: `[\t\n\f\r\p{Z}]`            |
|  \S  | 匹配非空格符: `[^\s]`                    |
|  \b  | 匹配单词的开始或结束                     |
|  \B  | 匹配非单词的开始或结束                   |
|  ^   | 匹配字符串的开始                         |
| [^x] | 匹配除了x意外的任意字符                  |
|  $   | 匹配字符串的结束                         |

#### . 匹配除换行符以外的任意字符

![image-20200508200933527](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200508200933527.png)

#### \w 匹配所有字母和数字的字符: `[a-zA-Z0-9_]`

![image-20200508201638106](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200508201638106.png)

#### \W 匹配非字母和数字的字符: `[^\w]`

#### \d 匹配数字: `[0-9]`

#### ![image-20200508202241226](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200508202241226.png)

#### \D 匹配非数字: `[^\d]`

![image-20200508204918965](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200508204918965.png)

#### \s 匹配空格符: `[\t\n\f\r\p{Z}]`

![image-20200508202056425](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200508202056425.png)

#### \S   匹配非空格符: `[^\s]`

![image-20200508202201805](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200508202201805.png)

#### \b 匹配单词的开始或结束

- 不加\b效果

  - ![image-20200508202605099](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200508202605099.png)

- 加上\b的效果

  - 两边都加上\b

    ![image-20200508202648126](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200508202648126.png)

  - 前面加上\b

    ![image-20200508203136632](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200508203136632.png)

  - 后面加上\b

    ![image-20200508203056898](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200508203056898.png)

#### \B 匹配非单词的开始或结束

- \B加前面

  ![image-20200508210556366](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200508210556366.png)

- \B加后面

  ![image-20200508210636521](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200508210636521.png)

#### ^\d+$

- \d+

  ![image-20200508204333501](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200508204333501.png)

- ^\d+

  ![image-20200508204512322](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200508204512322.png)

- \d+$

  ![image-20200508204528259](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200508204528259.png)

- ^\d+$

  ![image-20200508204558902](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200508204558902.png)

#### [^good] 匹配除了good以外的任意字符![image-20200508211528319](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200508211528319.png)

### 2.字符转义

正则表达式中使用反斜杠 `\` 来转义下一个字符。这将允许你使用保留字符来作为匹配字符 `{ } [ ] / \ + * . $ ^ | ?`。在特殊字符前面加 `\`，就可以使用它来做匹配字符。
例如正则表达式 `.` 是用来匹配除了换行符以外的任意字符。现在要在输入字符串中匹配 `.` 字符，正则表达式 `(f|c|m)at\.?`，表示: 小写字母 `f`、`c` 或者 `m` 后跟小写字母 `a`，后跟小写字母 `t`，后跟可选的 `.` 字符。

### 3. 元字符

元字符是正则表达式的基本组成元素。元字符在这里跟它通常表达的意思不一样，而是以某种特殊的含义去解释。有些元字符写在方括号内的时候有特殊含义。
元字符如下:

| 元字符 | 描述                                                         |
| :----: | ------------------------------------------------------------ |
|   .    | 匹配除换行符以外的任意字符。                                 |
|  [ ]   | 字符类，匹配方括号中包含的任意字符。                         |
|  [^ ]  | 否定字符类。匹配方括号中不包含的任意字符                     |
|   *    | 匹配前面的子表达式零次或多次                                 |
|   +    | 匹配前面的子表达式一次或多次                                 |
|   ?    | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。       |
| {n,m}  | 花括号，匹配前面字符至少 n 次，但是不超过 m 次。             |
| (xyz)  | 字符组，按照确切的顺序匹配字符xyz。                          |
| &#124; | 分支结构，匹配符号之前的字符或后面的字符。                   |
| &#92;  | 转义符，它可以还原元字符原来的含义，允许你匹配保留字符 <code>[ ] ( ) { } . * + ? ^ $ \ &#124;</code> |
|   ^    | 匹配行的开始                                                 |
|   $    | 匹配行的结束                                                 |

#### .和*和？

- .*d 匹配以d结尾的字符

  ![image-20200508215058124](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200508215058124.png)

- .d 匹配以d结尾的，并且包含他前面的一个字符

  ![image-20200508215338908](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200508215338908.png)

- .?d 匹配以d结尾的，并且包含他前面的一个字符

  ![image-20200508215406130](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200508215406130.png)

- \b.?ld\b

  ![image-20200508220659197](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200508220659197.png)

- ^.?ld$

  解读：^和$z做字符限定，.?ld表示匹配以ld结尾，前面只能有一个字符

  ![image-20200509090347023](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200509090347023.png)

#### [^x] 

- [abc]ld 匹配ld前面是以a、b、c开头的

  ![image-20200509091014176](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200509091014176.png)

- [^abc]ld 匹配ld前面是非以a、b、c开头的

  ![image-20200509091210913](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200509091210913.png)

#### 3.1.重复

以下元字符 `+`，`*` 或 `?` 用于指定子模式可以出现多少次。这些元字符在不同情况下的作用不同。

##### 3.1.1 星号

该符号 `*` 表示匹配上一个匹配规则的零次或多次。正则表达式 `a*` 表示小写字母 `a` 可以重复零次或者多次。但是它如果出现在字符集或者字符类之后，它表示整个字符集的重复。
例如正则表达式 `[a-z]*`，表示: 一行中可以包含任意数量的小写字母。

<pre>
"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.
</pre>


该 `*` 符号可以与元符号 `.` 用在一起，用来匹配任意字符串 `.*`。该 `*` 符号可以与空格符 `\s` 一起使用，用来匹配一串空格字符。
例如正则表达式 `\s*cat\s*`，表示: 零个或多个空格，后面跟小写字母 `c`，再后面跟小写字母 `a`，再再后面跟小写字母 `t`，后面再跟零个或多个空格。

<pre>
"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the <a href="#learn-regex"><strong>cat</strong></a>.
</pre>


##### 3.1.2 加号

该符号 `+` 匹配上一个字符的一次或多次。例如正则表达式 `c.+t`，表示: 一个小写字母 `c`，后跟任意数量的字符，后跟小写字母 `t`。

<pre>
"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.
</pre>

##### 3.1.3 问号

在正则表达式中，元字符 `?` 用来表示前一个字符是可选的。该符号匹配前一个字符的零次或一次。
例如正则表达式 `[T]?he`，表示: 可选的大写字母 `T`，后面跟小写字母 `h`，后跟小写字母 `e`。

<pre>
"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.
</pre>
<pre>
"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.
</pre>

##### 例子

- 0\d{2,3}-\d{7,8}

![image-20200509111007042](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200509111007042.png)

tip：我们会发现匹配的第二个号码后面还有个9，那么我们该如何加上限定，不让他匹配后面的呢，就用到了前面学的^和$,来看示例

![image-20200509110946231](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200509110946231.png)

tip:上面的例子确实匹配到了正确的号码，但真实生活中的例子往往是每个地区的电话号码写法都不一样，看下图示例如何解决![image-20200509112321371](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200509112321371.png)

ps:上面的例子很多条件放到了一起，不利于阅读，我们可以用分支来解决，符合其中任一一种正则即可，看下图示例

![image-20200509112923569](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200509112923569.png)

### 4.分组

将表达式进行做成子集

使用()进行分组

方便match的字符串进行划分

分组的命名：(?<groupname>exp)

(?:exp) 匹配exp，不捕获匹配的文本，也不给分组分配组号

```
<div\s+class="(?:result|result-op)\s+c-container\s+.*?<a.*?>(?<baiduTitle>.*?)</a>
```

![image-20200509163303405](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200509163303405.png)

### 5.贪婪与懒惰

懒惰

| 语法  |               说明               |
| :---: | :------------------------------: |
|  *？  |    重复任意次，但尽可能少重复    |
|  +？  | 重复一次或更多次，但尽可能少重复 |
| ？？  | 重复0次或更多次，但尽可能少重复  |
| {n,m} |   重复n次到m次，但尽可能少重复   |
| {n,}  |   重复n次以上，但尽可能少重复    |



- 贪婪

  所谓贪婪就是尽可能多的匹配，它遇到第一个b不结束，遇到最后一个b才结束

  ![image-20200509113945988](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200509113945988.png)

- 懒惰

  遇到个b就匹配成功

  ![image-20200509114228281](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200509114228281.png)

### 6.处理选项

|          语法           |                             说明                             |
| :---------------------: | :----------------------------------------------------------: |
|       IgnoreCase        |                      匹配时不区分大小写                      |
|        Multiline        | 更改^和$的含义，是它们分别在任意一行的行首和行尾匹配，而不仅仅在整个字符串的开头和结尾匹配。(在此模式下，$的精确的含义是：匹配\n之前的位置以及字符串结束前的位置) |
|       Singleline        |       更改.的含义，使它与每一个字符匹配(包括换行符\n)        |
| IgnorePatternWhitespace |         忽略表达式中的非转义空白并启用由#标记的注释          |
|     ExplicitCapture     |                    仅捕获已被显式命名的组                    |

### 7.反向引用

匹配taobao taobao,home home 这样的情况

\b(\w+)\b\s+\1\b

\b(?<Word>\w+)\b\s+\k<Word>\b  命名后的写法

例一：

```
\b(\w+)\b\s+\1\s+\1
```

![image-20200509203117776](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200509203117776.png)

### 8.零宽断言

#### 正向零宽断言

?=exp 零宽度正预测先行断言，自身出现的位置的后面能匹配表达式

exp

```
\b\w+(?=ing\b)
```

![image-20200509190747889](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200509190747889.png)

#### 零宽度正回顾后发断言

?<=exp 零宽度正回顾后发断言，自身出现的位置的前面能匹配表达式

exp

```
<?<=\bre>\w+\b
```

![image-20200509191003290](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200509191003290.png)

#### 负向零宽断言

查找这样的单词，它里面出现了字母q，但q后面跟的不是字母u

不用断言的方式

```
\b\w*q[^]\w*\b
```

![image-20200509190038301](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200509190038301.png)

使用断言 不消费任何字符

例一：

```
\b\w*q(!u)\w\b
```

![image-20200509185934605](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200509185934605.png)

例二：前面三位是数字，后面不能是数字

```
\d{3}(?!\d)
```

![image-20200509195248044](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200509195248044.png)

#### 零宽度负回顾后发断言

例一：前面不是小写字母的7位数字

```
(?<![a-z])\d{7}
```

![image-20200509201245152](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200509201245152.png)

#### 断言综合示例

例一：找出所有个位数

```
(?<=\s+)\d(?=\s+)|(?<!\d)\d(?!\d)
```

![image-20200509203808715](%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/images/image-20200509203808715.png)